matrixperm:=function(A,c1,c2)
local B,C,CC;
	B:=TransposedMat(A);
	C:=ShallowCopy(B);
	C[c1]:=B[c2];
	C[c2]:=B[c1];
	CC:=TransposedMat(C);
	return CC;
end;

####subfunction that removes a "list" of rows in matrix "A"
Myremove:=function(A,list)
local B,i;
Sort(list);
B:=ShallowCopy(A);
Remove(B,list[1]);
if Size(list)>1 then
	for i in [2..Size(list)] do
		Remove(B,list[i]-i+1);
	od;
fi;
return B;
end;

#############subfunction that removes a "list" of columns in matrix "A"
Myremovetrans:=function(A,list)
local B;
B:=TransposedMat(A);
B:=Myremove(B,list);
B:=TransposedMat(B);
return B;
end;

##############subfunction that: 
##############1. removes edge capacity constaints(ROWS of matrix [A|b]) H(listofedges[i])<=R(listofedges[i]) 
##############2. permutes edge capacity variables R(listofedges[i]) with edge entropy variable H(listofedges[i]) (COLUMNS of matrix [A|b])
##############2. removes edge capacity variables (COLUMNS of matrix A after step 2) R(listofedges[i])
getridandtrans:=function(ncinstance,A,b,linrows,listofedges)
local j,rrlist,conineq,Aprime,bprime,L,Lprime,linrowsprime,i,k,c1,c2;
Aprime:=ShallowCopy(A);
rrlist:=[];
for j  in listofedges  do
	conineq 
	 := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3] ] );
	conineq[j] := -1;
	conineq[ncinstance[3] + set2int( [ j ] )] := 1;
    for i in [1..Size(A)] do
		if A[i]=conineq then
		   Append(rrlist,[i]);
		fi;
    od;
od;
Aprime:=Myremove(Aprime,rrlist);
bprime:=Myremove(b,rrlist);
L:= ZeroMutable( [1..Size(b)] );
for k in [1..Size(linrows)] do
	L[linrows[k]]:=1;
od;
Lprime:=Myremove(L,rrlist);
linrowsprime:=[];
for k in [1..Size(Lprime)] do
	if Lprime[k]=1 then
		Append(linrowsprime,[k]);
	fi;
od;
rrlist:=[];
for i in listofedges do
    c1:=i;
    c2:=ncinstance[3] + set2int([i]);
	Aprime:=matrixperm(Aprime,c1,c2); 
	Append(rrlist,[c2]);
od;
Aprime:=Myremovetrans(Aprime,rrlist);
return [Aprime,bprime,linrowsprime];
end;

Justmatrixperm:=function(A,ncinstance,listofedges)
local i,c1,c2,Aprime;
Aprime:=ShallowCopy(A);
for i in listofedges do
	c1:=i;
	c2:=ncinstance[3] + set2int([i]);
	Aprime:=matrixperm(Aprime,c1,c2);
od;
return Aprime;
end;
#######function that computes the outer bound of a sink-source merged network containing N1+N2 variables,
#######where N1 and N2 denotes the number of variables in network net1_sink and that in network net2_source, respectively.
NCRateRegionOBGRO:=function ( ncinstance, usesym, optargs,listofedges)
    local  rlist, A, b,A1,b1, linrows, G, rlist1, ineq, ineqorb, row, rrA, rrb, 
    onemap, nslist, idx, nsrec, los, lolos, Oi, O, trans_ineq,i,j,c,list,dif,Ab,conineq;
    rlist := NCShannonBoundedNosumto1( ncinstance);
    A := rlist[1];
    b := rlist[2];
    linrows := rlist[3];
    if usesym = false  then
        G := Group( [ () ] );
    else
        G := NetSymGroup( ncinstance );
    fi;
    if Size( optargs ) > 0  then
        nslist := [  ];
        nsrec := optargs[1];
        for idx  in RecNamesInt( nsrec )  do
            lolos := nsrec.(idx);
            for los  in lolos  do
                if idx = 1  then
                    ineq := ZYNonShannon( los, ncinstance[3] );
                    ineqorb := Orbit( G, ineq, OnEntropySpace );
                    Append( nslist, ineqorb );
                else
                    ineq := DFZNonShannon( idx - 1, los, ncinstance[3] );
                    ineqorb := Orbit( G, ineq, OnEntropySpace );
                    Append( nslist, ineqorb );
                fi;
            od;
        od;
        Append( A, nslist );
        Append( b, ZeroMutable( [ 1 .. Size( nslist ) ] ) );
    fi;
    #####Getting rid of rows and switch columns
    Ab:=getridandtrans(ncinstance,A,b,linrows,listofedges);
    A1:=Ab[1];
    b1:=Ab[2];
    linrows:=Ab[3];
   A:=[];
   for i in [1..Size(A1)] do
	Append(A,[A1[i]]);
   od;
    conineq := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3]-Size(listofedges) ] );
    for j  in [ 1 .. ncinstance[3] ]  do
        conineq[j] := 1;  
    od;
    Append( A, [ conineq ] );
    Append( b1, [ 1 ] );#####R<Rvalue
    #####
    rlist1 := symCHM( A, b1, linrows, ncinstance[3], G, OnProjPts, OnProjIneq, 
       false );
    Display( Concatenation( "stats:  No. of LPs solved = ", 
       String( rlist1[3][1] ), ", \n\t No. of facets = ", 
       String( Size( rlist1[2] ) ), 
       ", \n\tDD stepsizes beyond initial hull = ", String( rlist1[3][2] ) ) 
     );
    rrA := [  ];
    rrb := [  ];
    for row  in rlist1[2]  do
        onemap := function ( x )
              return 1;
          end;
        if not row = List( [ 1 .. Size( row ) ], onemap )  then
            Append( rrA, [ row{[ 1 .. Size( row ) - 1 ]} ] );
            Append( rrb, [ row[Size( row )] ] );
        fi;
    od;
    trans_ineq := [  ];
    Oi := OrbitsDomain( G, rrA, OnProjIneq );
    for O  in Oi  do
        Append( trans_ineq, [ O[1] ] );
    od;
    return [ trans_ineq, RRparse( ncinstance, trans_ineq ),rlist1];
end;
